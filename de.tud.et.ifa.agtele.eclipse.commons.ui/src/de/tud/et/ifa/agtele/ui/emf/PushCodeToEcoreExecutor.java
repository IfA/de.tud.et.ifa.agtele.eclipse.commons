/**
 *
 */
package de.tud.et.ifa.agtele.ui.emf;

import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EOperation;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.ETypedElement;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.edit.domain.EditingDomain;
import org.eclipse.jdt.core.IImportDeclaration;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.IMethod;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.internal.core.CompilationUnit;
import org.eclipse.jdt.internal.core.SourceField;
import org.eclipse.jface.text.TextSelection;
import org.eclipse.jface.viewers.ISelection;

import de.tud.et.ifa.agtele.emf.AgteleEcoreUtil;
import de.tud.et.ifa.agtele.ui.emf.GeneratedEMFCodeHelper.GeneratedEMFCodeHelperException;
import de.tud.et.ifa.agtele.ui.handlers.PushCodeToEcoreHandler.AddImplementationEcoreAnnotationCommand;
import de.tud.et.ifa.agtele.ui.util.UIHelper;

/**
 * Instances of this class are responsible for pushing manual changes to Java code generated by EMF to the corresponding
 * metamodel to keep both metamodel and generated code in sync.
 *
 * @author lbaron, mfreund
 */
@SuppressWarnings("restriction")
public class PushCodeToEcoreExecutor {

	/**
	 * The {@link GeneratedEMFCodeHelper} representing the {@link CompilationUnit} on which this executor performs its
	 * work.
	 */
	protected GeneratedEMFCodeHelper helper;

	/**
	 * The {@link ResourceSet} containing the metamodel to which the code shall be pushed.
	 */
	protected ResourceSet resourceSet;

	/**
	 * This creates an instance.
	 *
	 * @param helper
	 *            The {@link GeneratedEMFCodeHelper} representing the {@link CompilationUnit} on which this executor
	 *            performs its work.
	 * @param resourceSet
	 *            The {@link ResourceSet} containing the metamodel to which the code shall be pushed or '<em>null</em>'
	 *            if no specific ResourceSet shall be used.
	 */
	public PushCodeToEcoreExecutor(GeneratedEMFCodeHelper helper, ResourceSet resourceSet) {

		this.helper = helper;
		this.resourceSet = resourceSet;
	}

	/**
	 * Push the code represented by the given {@link ISelection} to the associated Ecore metamodel.
	 *
	 * @see #pushToEcore(IJavaElement)
	 *
	 * @param javaSelection
	 *            The {@link ISelection} indicating the {@link IJavaElement} to be pushed to the metamodel.
	 * @return The {@link PushCodeToEcoreResult result} of the push.
	 * @throws PushCodeToEcoreExecutorException
	 *             If something went wrong, e.g. if the required associated metamodel element could not be determined.
	 */
	public PushCodeToEcoreResult pushToEcore(ISelection javaSelection) throws PushCodeToEcoreExecutorException {

		IJavaElement javaElement = null;
		try {
			javaElement = this.helper.getCompilationUnit().getElementAt(((TextSelection) javaSelection).getOffset());
		} catch (JavaModelException e) {
			throw new PushCodeToEcoreExecutorException(e);
		}

		return this.pushToEcore(javaElement);
	}

	/**
	 * Push the code represented by the given {@link ISelection} to the associated Ecore metamodel.
	 *
	 * @see #pushToEcore(ISelection)
	 *
	 * @param javaElement
	 *            The {@link IJavaElement} to be pushed to the metamodel.
	 * @return The {@link PushCodeToEcoreResult result} of the push.
	 * @throws PushCodeToEcoreExecutorException
	 *             If something went wrong, e.g. if the required associated metamodel element could not be determined.
	 */
	public PushCodeToEcoreResult pushToEcore(IJavaElement javaElement) throws PushCodeToEcoreExecutorException {

		String mainTypeName = String.valueOf(this.helper.getCompilationUnit().getMainTypeName());
		EMFGeneratedJavaFileType type = EMFGeneratedJavaFileType.getFileType(mainTypeName);

		EObject specificEcoreElement;
		try {
			specificEcoreElement = this.helper.getMoreSpecificSelection(javaElement);
		} catch (GeneratedEMFCodeHelperException e1) {
			throw new PushCodeToEcoreExecutorException(e1);
		}

		if (this.resourceSet != null) {
			specificEcoreElement = AgteleEcoreUtil.getEquivalentElementFrom(specificEcoreElement, this.resourceSet);
		}

		String detailsKey = null;
		String code = null;

		if (type.isClassImplementationType()) {
			if (specificEcoreElement instanceof EOperation) {
				detailsKey = "body";
				IMethod method = (IMethod) javaElement;
				try {
					code = method.getSource();
				} catch (JavaModelException e) {
					throw new PushCodeToEcoreExecutorException("Could not retrieve method source code.", e);
				}
				code = this.compileImplementation(code, this.helper.getCompilationUnit(), true, false);
			} else if ((specificEcoreElement instanceof EReference || specificEcoreElement instanceof EAttribute)
					&& javaElement instanceof IMethod) {
				IMethod method = (IMethod) javaElement;
				try {
					code = method.getSource();
				} catch (JavaModelException e) {
					throw new PushCodeToEcoreExecutorException("Could not retrieve method source code.", e);
				}
				String name = method.getElementName();
				if (name.startsWith("set")) {
					detailsKey = "set";
					code = this.compileImplementation(code, this.helper.getCompilationUnit(), true, false);
				} else if (name.startsWith("get")) {
					detailsKey = "get";
					code = this.compileImplementation(code, this.helper.getCompilationUnit(), true, false);
				} else if (name.startsWith("basicSet")) {
					detailsKey = "basicSet";
					code = this.compileImplementation(code, this.helper.getCompilationUnit(), true, false);
				} else if (name.startsWith("basicGet")) {
					detailsKey = "basicGet";
					code = this.compileImplementation(code, this.helper.getCompilationUnit(), true, false);
				}
				// //The eIsSet expression cannot be pushed to the ecore, without further work on identifying the ecore
				// element from the selection within the java method
				// else if (name.startsWith("eIsSet")) {
				// detailsKey = "isSet";
				// // determine the expression, it should follow: case --.CLASS_NAME__FEATURE_NAME:\n return
				// }
			} else if (specificEcoreElement instanceof EAttribute && javaElement instanceof SourceField) {
				detailsKey = "init";
				try {
					code = ((SourceField) javaElement).getSource();
				} catch (JavaModelException e) {
					throw new PushCodeToEcoreExecutorException("Could not retrieve field initialization source code.",
							e);
				}
				code = this.compileImplementation(code, this.helper.getCompilationUnit(), false, true);

			} else {
				throw new PushCodeToEcoreExecutorException(
						"Could not handle selection or ecore target element, this is probably due to a section of the source code, that cannot be pushed to the ecore model.");
			}
		} else if (type.isEditItemProviderType()) {
			if (javaElement instanceof IMethod
					&& (specificEcoreElement instanceof EAttribute || specificEcoreElement instanceof EReference
							&& !((EReference) specificEcoreElement).isContainment())) {
				detailsKey = "propertyDescriptor";
				try {
					code = ((IMethod) javaElement).getSource();
				} catch (JavaModelException e) {
					throw new PushCodeToEcoreExecutorException(
							"Could not retrieve add property descriptor source code.", e);
				}
				code = this.compileImplementation(code, this.helper.getCompilationUnit(), true, false);
			}
		}

		AddImplementationEcoreAnnotationCommand cmd = new AddImplementationEcoreAnnotationCommand(
				(ETypedElement) specificEcoreElement, detailsKey, code);

		EditingDomain dom = AgteleEcoreUtil.getEditingDomainFor(specificEcoreElement);
		dom.getCommandStack().execute(cmd);

		// set the selection in the ecore editor either to the details key or the manipulated annotation
		Object target = null;
		Object entrySet[] = cmd.getManipulatedAnnotation().getDetails().entrySet().toArray();
		if (code != null) {
			target = entrySet[cmd.getManipulatedAnnotation().getDetails().indexOfKey(detailsKey)];
		} else if (cmd.getManipulatedAnnotation() != null) {
			target = cmd.getManipulatedAnnotation();
		} else {
			target = specificEcoreElement;
		}

		return new PushCodeToEcoreResult(target, code != null
				? "Pushed the java code to the ecore model, to enable getters, setters, initializers or isSet evaluations, use custom emitter templates"
				: "Cleared the java code from the ecore model. Run the generator in order to get the default implementation.");
	}

	/**
	 * Compiles the java implementation for pushing it to the ecore. The compilation includes the removal of preceding
	 * whitespace and replacing unqualified Symbols with their qualified versions.
	 *
	 * @param code
	 *            The code to compile
	 * @param compilationUnit
	 *            the java compilation unit where the code fragment originates
	 * @return the modified code version
	 */
	protected String compileImplementation(String code, CompilationUnit compilationUnit, boolean isMethod,
			boolean isInitialization) {

		IImportDeclaration imports[] = null;
		try {
			imports = compilationUnit.getImports();
		} catch (JavaModelException e) {
			UIHelper.log(e);
			return code;
		}

		// remove leading comments
		code = code.trim();
		while (code.startsWith("/*")) {
			code = code.substring(code.indexOf("*/") + 2).trim();
		}

		// get implementation body
		if (isMethod) {
			code = code.substring(code.indexOf("{") + 1, code.lastIndexOf("}")); // do not trim here, we want the
																					// whitespace at the beginning of
																					// the line
		} else if (isInitialization) {
			if (!code.contains("=")) {
				return null;
			}
			code = code.substring(code.indexOf("=") + 1);
		}

		// make type Symbols fully qualified
		for (IImportDeclaration import1 : imports) {
			String importDeclaration = import1.getElementName();
			if (importDeclaration.endsWith(".*")) {
				continue;
			}
			int lastDotIndex = importDeclaration.lastIndexOf(".");
			String packageName = importDeclaration.substring(0, lastDotIndex);
			String typeName = importDeclaration.substring(lastDotIndex + 1);

			code = code.replaceAll("([\\(\\[\\{\\s<])" + typeName + "([\\s\\)>\\.])",
					"$1<%" + packageName + "." + typeName + "%>$2");
		}

		if (isInitialization) {
			return code;
		}

		// remove preceding whitespace
		String result = "";

		// determine the minimum count of whitespace characters at the beginnint of all lines
		int minSpaceCount = 999999;
		String[] lines;
		String nl;
		if (code.contains("\n\r")) {
			lines = code.split("\n\r");
			nl = "\n\r";
		} else if (code.contains("\r\n")) {
			lines = code.split("\r\n");
			nl = "\r\n";
		} else if (code.contains("\r")) {
			lines = code.split("\r");
			nl = "\r";
		} else {
			lines = code.split("\n");
			nl = "\n";
		}
		if (lines.length <= 1) {
			result = code;
		} else {
			for (String line2 : lines) {
				String s = line2;
				int spaceCount = 0;
				boolean empty = true;
				for (int i = 0; i < s.length(); i += 1) {
					if (s.charAt(i) == " ".charAt(0)) {
						spaceCount += 1;
					} else if (s.charAt(i) == "\t".charAt(0)) {
						spaceCount += 4;
					} else if (!Character.isWhitespace(s.charAt(i))) {
						empty = false;
						break;
					}
				}
				if (!empty && spaceCount < minSpaceCount) {
					minSpaceCount = spaceCount;
				}
			}
		}

		// remove a the minimal count of whitespace characters
		if (minSpaceCount >= 999999) {
			result = code;
		} else {
			for (String line2 : lines) {
				String s = line2;
				int charCount = 0;
				int charWeight = 0;
				for (int i = 0; i < s.length(); i += 1) {
					if (s.charAt(i) == " ".charAt(0)) {
						charCount += 1;
						charWeight += 1;
					} else if (s.charAt(i) == "\t".charAt(0)) {
						charCount += 1;
						charWeight += 4;
					} else if (!Character.isWhitespace(s.charAt(i))) {
						break;
					}
					if (charWeight >= minSpaceCount) {
						break;
					}
				}
				result += (result.length() > 0 ? nl : "") + s.substring(charCount <= s.length() ? charCount : 0);
			}
		}

		return result.trim();
	}

	/**
	 * A simple POJO indicating the result of a {@link PushCodeToEcoreExecutor push to ecore}.
	 *
	 * @author mfreund
	 */
	public class PushCodeToEcoreResult {

		/**
		 * This creates an instace.
		 *
		 * @param target
		 *            The target element of the push.
		 * @param result
		 *            A String indicating the result of the push.
		 */
		public PushCodeToEcoreResult(Object target, String result) {

			super();
			this.target = target;
			this.result = result;
		}

		/**
		 * The target element of the push.
		 */
		private Object target;

		/**
		 * A String indicating the result of the push.
		 */
		private String result;

		/**
		 * @return the {@link #target}
		 */
		public Object getTarget() {

			return this.target;
		}

		/**
		 * @param target
		 *            the target to set
		 */
		public void setTarget(Object target) {

			this.target = target;
		}

		/**
		 * @return the {@link #result}
		 */
		public String getResult() {

			return this.result;
		}

		/**
		 * @param result
		 *            the result to set
		 */
		public void setResult(String result) {

			this.result = result;
		}
	}

	/**
	 * An {@link Exception} indicating an error during the execution of a {@link PushCodeToEcoreExecutor}.
	 *
	 * @author mfreund
	 */
	public class PushCodeToEcoreExecutorException extends Exception {

		/**
		 *
		 */
		private static final long serialVersionUID = 744525392807163282L;

		/**
		 *
		 * @param message
		 * @param cause
		 */
		public PushCodeToEcoreExecutorException(String message, Throwable cause) {

			super(message, cause);
		}

		/**
		 *
		 * @param message
		 */
		public PushCodeToEcoreExecutorException(String message) {

			super(message);
		}

		/**
		 *
		 * @param cause
		 */
		public PushCodeToEcoreExecutorException(Throwable cause) {

			super(cause);
		}

	}
}
