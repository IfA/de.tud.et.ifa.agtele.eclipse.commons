/**
 *
 */
package de.tud.et.ifa.agtele.ui.emf;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map.Entry;
import java.util.Optional;

import org.eclipse.emf.ecore.EAnnotation;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EOperation;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.ETypedElement;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.edit.domain.EditingDomain;
import org.eclipse.jdt.core.IImportDeclaration;
import org.eclipse.jdt.core.IJavaElement;
import org.eclipse.jdt.core.IMethod;
import org.eclipse.jdt.core.ISourceRange;
import org.eclipse.jdt.core.ISourceReference;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.SourceRange;
import org.eclipse.jdt.core.ToolFactory;
import org.eclipse.jdt.core.formatter.CodeFormatter;
import org.eclipse.jdt.internal.core.CompilationUnit;
import org.eclipse.jdt.internal.core.SourceField;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.text.TextSelection;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.text.edits.MultiTextEdit;
import org.eclipse.text.edits.TextEdit;

import de.tud.et.ifa.agtele.emf.AgteleEcoreUtil;
import de.tud.et.ifa.agtele.ui.emf.GeneratedEMFCodeHelper.GeneratedEMFCodeHelperException;
import de.tud.et.ifa.agtele.ui.handlers.PushCodeToEcoreHandler.AddImplementationEcoreAnnotationCommand;
import de.tud.et.ifa.agtele.ui.util.UIHelper;

/**
 * Instances of this class are responsible for pushing manual changes to Java code generated by EMF to the corresponding
 * metamodel to keep both metamodel and generated code in sync.
 *
 * @author lbaron, mfreund
 */
@SuppressWarnings("restriction")
public class PushCodeToEcoreExecutor {

	/**
	 * The {@link GeneratedEMFCodeHelper} representing the {@link CompilationUnit} on which this executor performs its
	 * work.
	 */
	protected GeneratedEMFCodeHelper helper;

	/**
	 * The {@link ResourceSet} containing the metamodel to which the code shall be pushed.
	 */
	protected ResourceSet resourceSet;

	/**
	 * This creates an instance.
	 *
	 * @param helper
	 *            The {@link GeneratedEMFCodeHelper} representing the {@link CompilationUnit} on which this executor
	 *            performs its work.
	 * @param resourceSet
	 *            The {@link ResourceSet} containing the metamodel to which the code shall be pushed or '<em>null</em>'
	 *            if no specific ResourceSet shall be used.
	 */
	public PushCodeToEcoreExecutor(GeneratedEMFCodeHelper helper, ResourceSet resourceSet) {

		this.helper = helper;
		this.resourceSet = resourceSet;
	}

	/**
	 * Based on the {@link GeneratedEMFCodeHelper#getFileType() fileType} of the Java file represented by the
	 * {@link #helper} and the concrete sub-type of the {@link IJavaElement} represented by the given
	 * {@link ISelection}, decide if this element can be pushed to the Ecore metamodel.
	 *
	 * @see #isPushable(IJavaElement)
	 *
	 * @param javaSelection
	 *            The {@link ISelection} indicating the {@link IJavaElement} that shall be checked.
	 * @return '<em>true</em>' if the given {@link IJavaElement} can be pushed (if a call to
	 *         {@link #compileImplementation(String, CompilationUnit, boolean, boolean)} should produce a valid result);
	 *         '<em>false</em>' otherwise.
	 */
	public boolean isPushable(ISelection javaSelection) {

		IJavaElement javaElement = null;
		try {
			javaElement = this.helper.getCompilationUnit().getElementAt(((TextSelection) javaSelection).getOffset());
		} catch (JavaModelException e) {
			return false;
		}

		return this.isPushable(javaElement);
	}

	/**
	 * Based on the {@link GeneratedEMFCodeHelper#getFileType() fileType} of the Java file represented by the
	 * {@link #helper} and the concrete sub-type of the given {@link IJavaElement}, decide if this element can be pushed
	 * to the Ecore metamodel.
	 *
	 * @see #isPushable(ISelection)
	 *
	 * @param javaElement
	 *            The {@link IJavaElement} that shall be checked.
	 * @return '<em>true</em>' if the given {@link IJavaElement} can be pushed (if a call to
	 *         {@link #compileImplementation(String, CompilationUnit, boolean, boolean)} should produce a valid result);
	 *         '<em>false</em>' otherwise.
	 */
	public boolean isPushable(IJavaElement javaElement) {

		EMFGeneratedJavaFileType type = this.helper.getFileType();

		EObject specificEcoreElement;
		try {
			specificEcoreElement = this.helper.getMoreSpecificSelection(javaElement);
		} catch (GeneratedEMFCodeHelperException e) {
			return false;
		}

		if (type.isClassImplementationType()) {

			if (specificEcoreElement instanceof EOperation) {
				return true;

			} else if ((specificEcoreElement instanceof EReference || specificEcoreElement instanceof EAttribute)
					&& javaElement instanceof IMethod) {

				IMethod method = (IMethod) javaElement;
				String name = method.getElementName();

				// The eIsSet expression cannot be pushed to the ecore, without further work on identifying the
				// ecore element from the selection within the java method
				//
				return name.startsWith("set") || name.startsWith("get") || name.startsWith("is")
						|| name.startsWith("basicSet") || name.startsWith("basicGet");

			} else if (specificEcoreElement instanceof EAttribute && javaElement instanceof SourceField) {
				return true;

			}

		} else if (type.isEditItemProviderType()) {

			return javaElement instanceof IMethod
					&& (specificEcoreElement instanceof EAttribute || specificEcoreElement instanceof EReference
							&& !((EReference) specificEcoreElement).isContainment());
		}

		return false;
	}

	/**
	 * Push the code represented by the given {@link ISelection} to the associated Ecore metamodel.
	 *
	 * @see #pushToEcore(IJavaElement)
	 *
	 * @param javaSelection
	 *            The {@link ISelection} indicating the {@link IJavaElement} to be pushed to the metamodel.
	 * @return The {@link PushCodeToEcoreResult result} of the push.
	 * @throws PushCodeToEcoreExecutorException
	 *             If something went wrong, e.g. if the required associated metamodel element could not be determined.
	 */
	public PushCodeToEcoreResult pushToEcore(ISelection javaSelection) throws PushCodeToEcoreExecutorException {

		IJavaElement javaElement = null;
		try {
			javaElement = this.helper.getCompilationUnit().getElementAt(((TextSelection) javaSelection).getOffset());
			while (javaElement.getParent() != null
					&& !this.helper.getCompilationUnit().equals(javaElement.getParent().getParent())) {
				javaElement = javaElement.getParent();
			}
		} catch (JavaModelException e) {
			throw new PushCodeToEcoreExecutorException(e);
		}

		return this.pushToEcore(javaElement);
	}

	/**
	 * Push the code represented by the given {@link ISelection} to the associated Ecore metamodel.
	 *
	 * @see #pushToEcore(ISelection)
	 *
	 * @param javaElement
	 *            The {@link IJavaElement} to be pushed to the metamodel.
	 * @return The {@link PushCodeToEcoreResult result} of the push.
	 * @throws PushCodeToEcoreExecutorException
	 *             If something went wrong, e.g. if the required associated metamodel element could not be determined.
	 */
	public PushCodeToEcoreResult pushToEcore(IJavaElement javaElement) throws PushCodeToEcoreExecutorException {

		if (!this.isPushable(javaElement)) {
			throw new PushCodeToEcoreExecutorException(
					"The JavaElement '" + javaElement.getElementName() + "' cannot be pushed to Ecore!");
		}

		// The basis for the annotation to be created
		//
		String[] annotationDescriptor = this.getAnnotationDescriptor(javaElement);

		// The target element for the annotation
		//
		EObject specificEcoreElement;
		try {
			specificEcoreElement = this.helper.getMoreSpecificSelection(javaElement);
		} catch (GeneratedEMFCodeHelperException e1) {
			throw new PushCodeToEcoreExecutorException(e1);
		}

		if (this.resourceSet != null) {
			specificEcoreElement = AgteleEcoreUtil.getEquivalentElementFrom(specificEcoreElement, this.resourceSet);
		}

		// The command that will do the actual work (create the annotation)
		//
		AddImplementationEcoreAnnotationCommand cmd = new AddImplementationEcoreAnnotationCommand(
				(ETypedElement) specificEcoreElement, annotationDescriptor[0], annotationDescriptor[1]);

		EditingDomain dom = AgteleEcoreUtil.getEditingDomainFor(specificEcoreElement);
		dom.getCommandStack().execute(cmd);

		// Set the selection in the Ecore editor either to the details key, the manipulated annotation, or the EObject
		//
		EAnnotation manipulatedAnnotation = cmd.getManipulatedAnnotation();

		Object target = specificEcoreElement;

		if (manipulatedAnnotation != null) {

			Optional<Entry<String, String>> detailsEntryToSelect = manipulatedAnnotation.getDetails().entrySet()
					.stream().filter(e -> annotationDescriptor[0] == e.getKey()).findAny();

			if (detailsEntryToSelect.isPresent()) {
				target = detailsEntryToSelect.get();
			} else {
				target = manipulatedAnnotation;
			}

		}

		return new PushCodeToEcoreResult(target, annotationDescriptor[1] != null
				? "Pushed the java code to the ecore model, to enable getters, setters, initializers or isSet evaluations, use custom emitter templates"
				: "Cleared the java code from the ecore model. Run the generator in order to get the default implementation.");
	}

	/**
	 * {@link CodeFormatter Formats} the source code of the given {@link ISourceReference javaElement} (as selecting
	 * 'Source -> Format Element' in the Java editor would do) and returns the formatted source code.
	 * <p />
	 * Note: This does not affect the actual editor contents because formatting is performed on a temporary document!
	 *
	 * @param javaElement
	 *            The {@link ISourceReference} whose source code shall be formatted.
	 * @return The formatted source code.
	 * @throws PushCodeToEcoreExecutorException
	 *             If formatting the compilation unit fails.
	 *
	 * @see <a href=
	 *      "https://stackoverflow.com/questions/16015240/formatting-source-code-programmatically-with-jdt">https://stackoverflow.com/questions/16015240/formatting-source-code-programmatically-with-jdt</a>
	 *
	 */
	protected String formatJavaElement(ISourceReference javaElement) throws PushCodeToEcoreExecutorException {

		try {

			String compilationUnitSource = this.helper.getCompilationUnit().getSource();

			CodeFormatter formatter = ToolFactory.createCodeFormatter(null);

			ISourceRange originalSourceRange = javaElement.getSourceRange();

			TextEdit formatEdit = formatter.format(CodeFormatter.K_COMPILATION_UNIT, compilationUnitSource,
					originalSourceRange.getOffset(), originalSourceRange.getLength(), 0, null);

			// Wrap the actual format TextEdit in a MultiTextEdit so that we are able to get the 'updatedSourceRange'
			// later on
			//
			MultiTextEdit javaElementEdit = new MultiTextEdit(originalSourceRange.getOffset(),
					originalSourceRange.getLength());
			javaElementEdit.addChild(formatEdit);

			// Apply the edit in a temporary document so that we do not affect the actual editor contents
			//
			Document tempDocument = new Document(compilationUnitSource);
			javaElementEdit.apply(tempDocument, TextEdit.UPDATE_REGIONS);

			ISourceRange updatedSourceRange = new SourceRange(javaElementEdit.getRegion().getOffset(),
					javaElementEdit.getRegion().getLength());

			return tempDocument.get(updatedSourceRange.getOffset(), updatedSourceRange.getLength());

		} catch (Exception e) {
			throw new PushCodeToEcoreExecutorException(e);
		}

	}

	/**
	 * For the given {@link IJavaElement} (that is part of the Java file represented by the {@link #helper}), return a
	 * descriptor for the {@link EAnnotation} to create during the push.
	 *
	 * @param javaElement
	 *            The {@link IJavaElement} for which to return the descriptor.
	 * @return A String array containing exactly two elements: The first element represents the <em>key</em> for the
	 *         annotation to create whereas the second element represents its <em>value</em> (the Java code representing
	 *         the implementation of the given {@link IJavaElement}).
	 * @throws PushCodeToEcoreExecutorException
	 *             If the descriptor could not be created.
	 */
	protected String[] getAnnotationDescriptor(IJavaElement javaElement) throws PushCodeToEcoreExecutorException {

		if (!(javaElement instanceof ISourceReference)) {
			throw new PushCodeToEcoreExecutorException(
					"Could not retrieve source code for JavaElement '" + javaElement.getElementName() + "'!");
		}

		EMFGeneratedJavaFileType type = this.helper.getFileType();

		EObject specificEcoreElement;
		try {
			specificEcoreElement = this.helper.getMoreSpecificSelection(javaElement);
		} catch (GeneratedEMFCodeHelperException e1) {
			throw new PushCodeToEcoreExecutorException(e1);
		}

		// The 'key' to be used for the annotation to be created
		//
		String detailsKey = null;

		boolean isMethod = false;
		boolean isInitialization = false;

		if (type.isClassImplementationType()) {
			if (specificEcoreElement instanceof EOperation) {

				detailsKey = "body";
				isMethod = true;

			} else if ((specificEcoreElement instanceof EReference || specificEcoreElement instanceof EAttribute)
					&& javaElement instanceof IMethod) {

				IMethod method = (IMethod) javaElement;
				String name = method.getElementName();
				if (name.startsWith("set")) {
					detailsKey = "set";
				} else if (name.startsWith("get") || name.startsWith("is")) {
					detailsKey = "get";
				} else if (name.startsWith("basicSet")) {
					detailsKey = "basicSet";
				} else if (name.startsWith("basicGet")) {
					detailsKey = "basicGet";
				}
				isMethod = true;

			} else if (specificEcoreElement instanceof EAttribute && javaElement instanceof SourceField) {

				detailsKey = "init";
				isInitialization = true;

			}

		} else if (type.isEditItemProviderType()) {
			if (javaElement instanceof IMethod
					&& (specificEcoreElement instanceof EAttribute || specificEcoreElement instanceof EReference
							&& !((EReference) specificEcoreElement).isContainment())) {

				detailsKey = "propertyDescriptor";
				isMethod = true;

			}
		}

		if (detailsKey == null) {
			throw new PushCodeToEcoreExecutorException(
					"Could not handle selection or ecore target element, this is probably due to a section of the source code, that cannot be pushed to the ecore model.");
		}

		// Before pushing the java element, format (indent, etc.) its content correctly so that regenerating the code
		// will result in the same format
		//
		String formattedJavaCode = this.formatJavaElement((ISourceReference) javaElement);

		// Additionally, extract the part of the source code to be pushed (e.g. only the method content), replace
		// unqualified symbols with their qualified versions, etc.
		//
		String compiledImplementation = this.compileImplementation(formattedJavaCode, this.helper.getCompilationUnit(),
				isMethod, isInitialization);

		if (compiledImplementation == null) {
			throw new PushCodeToEcoreExecutorException(
					"Unable to compile implementation for JavaElement '" + javaElement.getElementName() + "'!");
		}

		return new String[] { detailsKey, compiledImplementation };
	}

	/**
	 * Compiles the java implementation for pushing it to the ecore. The compilation includes the removal of preceding
	 * whitespace and replacing unqualified Symbols with their qualified versions.
	 *
	 * @param code
	 *            The code to compile
	 * @param compilationUnit
	 *            the java compilation unit where the code fragment originates
	 * @return the modified code version
	 */
	protected String compileImplementation(String code, CompilationUnit compilationUnit, boolean isMethod,
			boolean isInitialization) {

		String compiledCode = code;

		IImportDeclaration[] imports = null;
		try {
			imports = compilationUnit.getImports();
		} catch (JavaModelException e) {
			UIHelper.log(e);
			return compiledCode;
		}

		// TODO extract the fetching of the implementation body into a util method
		// remove leading comments
		compiledCode = compiledCode.trim();
		while (compiledCode.startsWith("/*") || compiledCode.startsWith("//") || compiledCode.startsWith("@")) {
			if (compiledCode.startsWith("/*")) {
				compiledCode = compiledCode.substring(compiledCode.indexOf("*/") + 2).trim();
			} else {
				compiledCode = compiledCode.substring(compiledCode.indexOf(System.lineSeparator()) + 1).trim();
			}
		}

		// get implementation body
		if (isMethod) {

			// do not trim here, we want the whitespace at the beginning of the line
			compiledCode = compiledCode.substring(compiledCode.indexOf("{") + 1, compiledCode.lastIndexOf("}"));

		} else if (isInitialization) {
			if (!compiledCode.contains("=")) {
				return null;
			}
			compiledCode = compiledCode.substring(compiledCode.indexOf("=") + 1);
		}

		// make type Symbols fully qualified
		for (IImportDeclaration import1 : imports) {
			String importDeclaration = import1.getElementName();
			if (importDeclaration.endsWith(".*")) {
				continue;
			}
			int lastDotIndex = importDeclaration.lastIndexOf(".");
			String packageName = importDeclaration.substring(0, lastDotIndex);
			String typeName = importDeclaration.substring(lastDotIndex + 1);

			compiledCode = compiledCode.replaceFirst("([\\(\\[\\{\\s<])" + typeName + "([\\s\\)<>:\\.,])",
					"$1<%" + packageName + "." + typeName + "%>$2");
		}

		if (isInitialization) {
			return compiledCode;
		}

		// remove preceding whitespace
		String result = "";

		// determine the minimum count of whitespace characters at the beginnint of all lines
		int minSpaceCount = 999999;
		String[] lineArray;
		String nl;
		if (compiledCode.contains("\r\n")) {
			lineArray = compiledCode.split("\r\n");
			nl = "\r\n";
		} else if (compiledCode.contains("\r")) {
			lineArray = compiledCode.split("\r");
			nl = "\r";
		} else {
			lineArray = compiledCode.split("\n");
			nl = "\n";
		}

		List<String> lines = new ArrayList<>(Arrays.asList(lineArray));

		if (lines.isEmpty()) {
			result = compiledCode;
		} else {

			// remove the line belonging to the beginning { and closing } if it is empty or does only contain whitespace
			// (these lines will be regenerated nonetheless)
			//
			if (lines.size() > 1) {
				String firstLine = lines.get(0);
				if (firstLine.isEmpty() || firstLine.matches("[\\s]+")) {
					lines.remove(0);
				}

				String lastLine = lines.get(lines.size() - 1);
				if (lastLine.isEmpty() || lastLine.matches("[\\s]+")) {
					lines.remove(lines.size() - 1);
				}
			}

			for (String line2 : lines) {
				String s = line2;
				int spaceCount = 0;
				boolean empty = true;
				for (int i = 0; i < s.length(); i += 1) {
					if (s.charAt(i) == " ".charAt(0)) {
						spaceCount += 1;
					} else if (s.charAt(i) == "\t".charAt(0)) {
						spaceCount += 4;
					} else if (!Character.isWhitespace(s.charAt(i))) {
						empty = false;
						break;
					}
				}
				if (!empty && spaceCount < minSpaceCount) {
					minSpaceCount = spaceCount;
				}
			}
		}

		// remove the minimal count of whitespace characters
		if (minSpaceCount >= 999999) {
			result = compiledCode;
		} else {

			List<String> resultLines = new ArrayList<>();

			for (String line2 : lines) {
				String s = line2;
				int charCount = 0;
				int charWeight = 0;
				for (int i = 0; i < s.length(); i += 1) {
					if (s.charAt(i) == " ".charAt(0)) {
						charCount += 1;
						charWeight += 1;
					} else if (s.charAt(i) == "\t".charAt(0)) {
						charCount += 1;
						charWeight += 4;
					} else if (!Character.isWhitespace(s.charAt(i))) {
						break;
					}
					if (charWeight >= minSpaceCount) {
						break;
					}
				}

				resultLines.add(s.substring(charCount <= s.length() ? charCount : 0));
				result = String.join(nl, resultLines);
			}
		}

		return result;
	}

	/**
	 * A simple POJO indicating the result of a {@link PushCodeToEcoreExecutor push to ecore}.
	 *
	 * @author mfreund
	 */
	public class PushCodeToEcoreResult {

		/**
		 * This creates an instace.
		 *
		 * @param target
		 *            The target element of the push.
		 * @param result
		 *            A String indicating the result of the push.
		 */
		public PushCodeToEcoreResult(Object target, String result) {

			super();
			this.target = target;
			this.result = result;
		}

		/**
		 * The target element of the push.
		 */
		private Object target;

		/**
		 * A String indicating the result of the push.
		 */
		private String result;

		/**
		 * @return the {@link #target}
		 */
		public Object getTarget() {

			return this.target;
		}

		/**
		 * @param target
		 *            the target to set
		 */
		public void setTarget(Object target) {

			this.target = target;
		}

		/**
		 * @return the {@link #result}
		 */
		public String getResult() {

			return this.result;
		}

		/**
		 * @param result
		 *            the result to set
		 */
		public void setResult(String result) {

			this.result = result;
		}
	}

	/**
	 * An {@link Exception} indicating an error during the execution of a {@link PushCodeToEcoreExecutor}.
	 *
	 * @author mfreund
	 */
	public class PushCodeToEcoreExecutorException extends Exception {

		/**
		 *
		 */
		private static final long serialVersionUID = 744525392807163282L;

		/**
		 *
		 * @param message
		 * @param cause
		 */
		public PushCodeToEcoreExecutorException(String message, Throwable cause) {

			super(message, cause);
		}

		/**
		 *
		 * @param message
		 */
		public PushCodeToEcoreExecutorException(String message) {

			super(message);
		}

		/**
		 *
		 * @param cause
		 */
		public PushCodeToEcoreExecutorException(Throwable cause) {

			super(cause);
		}

	}
}
